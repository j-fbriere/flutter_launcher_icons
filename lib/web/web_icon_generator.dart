import 'dart:convert';
import 'dart:io';

import 'package:image/image.dart';
import 'package:path/path.dart' as path;

import '../abs/icon_generator.dart';
import '../constants.dart' as constants;
import '../custom_exceptions.dart';
import '../utils.dart' as utils;
import 'web_template.dart';

final metaTagsTemplate = (
  String appleMobileWebAppTitle,
  String appleMobileWebAppStatusBarStyle, {
    List<int>? iconSizes,
    List<int>? faviconSizes,
  }) {
  List<int> actualIconSizes = iconSizes ?? [192, 512];
  String appleTouchIconLines = actualIconSizes.fold('', (prevVal, sz) => '$prevVal  <link rel="apple-touch-icon" href="icons/icon-${sz}x$sz.png" sizes="${sz}x$sz">\n');
  List<int> actualFaviconSizes = faviconSizes ?? [16];
  String faviconLines = actualFaviconSizes.fold('', (prevVal, sz) => '$prevVal  <link rel="icon" type="image/png" href="favicon-${sz}x$sz.png">\n');
  return '''  <!--Generated by Flutter Launcher Icons--START-->
  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="$appleMobileWebAppStatusBarStyle">
  <meta name="apple-mobile-web-app-title" content="$appleMobileWebAppTitle">
$appleTouchIconLines
  <!-- Favicon -->
$faviconLines
  <link rel="manifest" href="manifest.json">
  <!--Generated by Flutter Launcher Icons--END-->''';
};

/// Generates Web icons for flutter
class WebIconGenerator extends IconGenerator {
  static const _defaultWebIconSizeTemplates = <WebIconTemplate>[
    WebIconTemplate(size: 192),
    WebIconTemplate(size: 512),
  ];

  /// Creates an instance of [WebIconGenerator].
  ///
  ///
  WebIconGenerator(IconGeneratorContext context) : super(context, 'Web');

  @override
  void createIcons() {
    final imgFilePath = path.join(
      context.prefixPath,
      context.webConfig!.imagePath ?? context.config.imagePath!,
    );

    context.logger
        .verbose('Decoding and loading image file at $imgFilePath...');
    final imgFile = utils.decodeImageFile(imgFilePath);
    if (imgFile == null) {
      context.logger.error('Image File not found at give path $imgFilePath...');
      throw FileNotFoundException(imgFilePath);
    }

    // generate favicon in web/favicon.png
    context.logger.verbose('Generating favicons from $imgFilePath...');
    _generateFavicons(imgFile);

    // generate icons in web/icons/
    context.logger.verbose('Generating icons from $imgFilePath...');
    _generateIcons(imgFile);

    // update manifest.json in web/mainfest.json
    context.logger.verbose(
      'Updating ${path.join(context.prefixPath, constants.webManifestFilePath)}...',
    );
    _updateManifestFile();

    _updateIndexFile();
  }

  @override
  bool validateRequirements() {
    // check if web config exists
    context.logger.verbose('Checking webconfig...');
    final webConfig = context.webConfig;
    if (webConfig == null || !webConfig.generate) {
      context.logger.error(
        'Web config is not provided or generate is false. Skipped...',
      );
      return false;
    }
    if (webConfig.imagePath == null && context.config.imagePath == null) {
      context.logger.error(
        'Invalid config. Either provide web.imagePath or imagePath'
      );
      return false;
    }
    if (webConfig.appleMobileWebAppTitle == null) {
      context.logger.error(
        'Invalid config. Must provide web.appleMobileWebAppTitle'
      );
      return false;
    }
    if (webConfig.appleMobileWebAppStatusBarStyle == null) {
      context.logger.error(
        'Invalid config. Must provide web.appleMobileWebAppStatusBarStyle'
      );
      return false;
    }

    // verify web platform related files and directories exists
    final entitiesToCheck = [
      path.join(context.prefixPath, constants.webDirPath),
      path.join(context.prefixPath, constants.webManifestFilePath),
      path.join(context.prefixPath, constants.webIndexFilePath),
    ];

    // web platform related files must exist to continue
    final failedEntityPath = utils.areFSEntitiesExist(entitiesToCheck);
    if (failedEntityPath != null) {
      context.logger.error(
        '$failedEntityPath this file or folder is required to generate web icons',
      );
    }

    return true;
  }

  void _generateFavicon(Image image, int size) {
    final favIcon = utils.createResizedImage(size, image);
    final favIconFile = utils.createFileIfNotExist(
      path.join(context.prefixPath, constants.webFaviconFilePath(size)),
    );
    favIconFile.writeAsBytesSync(encodePng(favIcon));
  }

  void _generateFavicons(Image image) {
    if (context.webConfig!.faviconSizes?.isNotEmpty ?? false) {
      for (int size in context.webConfig!.faviconSizes!) {
        _generateFavicon(image, size);
      }
    }
    else {
      _generateFavicon(image, constants.kFaviconSize);
    }
  }

  List<WebIconTemplate> _getTemplateLst() {
    List<WebIconTemplate> templateLst;
    if (context.webConfig!.iconSizes?.isNotEmpty ?? false) {
      templateLst = context.webConfig!.iconSizes!.map((e) => WebIconTemplate(size: e)).toList();
    }
    else {
      templateLst = _defaultWebIconSizeTemplates;
    }
    return templateLst;
  }

  void _generateIcons(Image image) {
    final iconsDir = utils.createDirIfNotExist(
      path.join(context.prefixPath, constants.webIconsDirPath),
    );

    // generate icons
    for (final template in _getTemplateLst()) {
      final resizedImg = utils.createResizedImage(template.size, image);
      final iconFile = utils.createFileIfNotExist(
        path.join(context.prefixPath, iconsDir.path, template.iconFile),
      );
      iconFile.writeAsBytesSync(encodePng(resizedImg));
    }
  }

  void _updateManifestFile() {
    final manifestFile = utils.createFileIfNotExist(
      path.join(context.prefixPath, constants.webManifestFilePath),
    );
    final manifestConfig =
      jsonDecode(manifestFile.readAsStringSync()) as Map<String, dynamic>;

    // update background_color
    if (context.webConfig?.backgroundColor != null) {
      manifestConfig['background_color'] = context.webConfig?.backgroundColor;
    }

    // update theme_color
    if (context.webConfig?.themeColor != null) {
      manifestConfig['theme_color'] = context.webConfig?.themeColor;
    }

    // replace existing icons to eliminate conflicts
    manifestConfig
      ..remove('icons')
      ..['icons'] = _getTemplateLst()
        .map<Map<String, dynamic>>((e) => e.iconManifest)
        .toList();

    manifestFile.writeAsStringSync(utils.prettifyJsonEncode(manifestConfig));
  }

  void _updateIndexFile() {
    File indexFile = File(path.join(context.prefixPath, constants.webIndexFilePath));
    if (!indexFile.existsSync()) {
      context.logger.error(
        'The index.html file is required to generate its content',
      );
      return;
    }
    String metaTagsTemplateLines = metaTagsTemplate(
      context.webConfig!.appleMobileWebAppTitle!,
      context.webConfig!.appleMobileWebAppStatusBarStyle!,
      iconSizes: context.webConfig!.iconSizes,
      faviconSizes: context.webConfig!.faviconSizes,
    );
    List<String> indexLines = indexFile.readAsLinesSync();
    List<String> newIndexLines = [];
    for (int i = 0; i < indexLines.length; i++) {
      String line = indexLines[i];
      if (RegExp(r'<!--.*iOS meta tags.*-->').hasMatch(line)) {
        newIndexLines.add(metaTagsTemplateLines);
      }
      else if (!RegExp(r'<!--.*Generated by Flutter.*-->|<meta\s.*name="apple-mobile-web-app|<link\s.*rel="apple-touch-icon"|<link\s.*rel="icon"|<!--.*Favicon.*-->|<link\s.*rel="manifest"').hasMatch(line)) {
        newIndexLines.add(line);
      }
    }
    String newIndexText = newIndexLines.join('\n');
    newIndexText = newIndexText.replaceAll(RegExp(r'\n\n\n+'), '\n\n');
    File newIndexFile = File(path.join(context.prefixPath, constants.webIndexFilePath));
    newIndexFile.writeAsStringSync(newIndexText);
  }
}
